/**
 * @author arturo argueta 
 * @version 1.0
 * 
 */
import java.util.ArrayList; 
import java.util.Random;
import java.util.Stack;

/**
 * TABLE OF COLORS
 *  1.- Green
 *  2.- White
 *  3.- Orange
 *  4.- Yellow
 *  5.- Red
 *  6.- Blue
 */
public class Solver {

	public static ArrayList<Integer> moves = new ArrayList<Integer>();
	public static Stack<Integer> theStack = new Stack<Integer>();
	public static void main(String[] args){

		long tStart = System.currentTimeMillis();
		
		/*
		 //FOR DEBUGING PURPOSES
		Cube theCube = new Cube();
		//theCube.turnDown(theCube.greenFace);
		theCube.turnBottom(theCube.greenFace);
		printCube(theCube);
		//*/
		
		//GENERATE A RANDOM CUBE
		Cube theCube = generateRandomCube();
		
		//SOLVE GREEN CROSS FIRST
		solveGreenCross(theCube);
		System.out.println("Green Cross Solved");
		
		//FINISH SOLVING THE GREEN SIDE
		solveGreenSideSecond(theCube);
		System.out.println("Green Side Solved");
		
		//SOLVE THE SECOND LAYER OF THE SIDES THAT NEIGHBOR THE GREEN SIDE
		solveSecondLayer(theCube);
		System.out.println("Second Layer Solved");
		
		//SOLVE THE CROSS ON TOP OF THE GREEN CROSS
		solveTopCross(theCube);
		System.out.println("Blue Cross Solved");
		
		//FINISH SOLVING THE BLUE SIDE (OR THE OPPOSITE SIDE)
		solveTop(theCube);
		System.out.println("Blue Top Solved");
		
		//SOLVE THE NEADLIGHTS 
		solveHeadlights(theCube);
		System.out.println("Solved Headlights");
		
		//FINISH SOLVING THE CUBE
		solveFinal(theCube);
		System.out.println("cube solved");
		
		
		//PRINT RESULTS
		printCube(theCube);
		long tEnd = System.currentTimeMillis();
		long tTotal = tEnd - tStart;
		double elapsedSeconds = tTotal / 1000.0;
		System.out.println("The total time is: "+elapsedSeconds+" seconds");

		//*/
	}


	/**
	 * Print all the sides of a Rubiks cube
	 * @param printCube this is the cube object we intend to print
	 */
	public static void printCube(Cube printCube){
		for(int i=1;i<7;i++){
			printCube.printSide(i);
		}
	}

	/**
	 * This method returns a randomly shuffled Rubiks cube 
	 * @return the random cube generated by this method
	 */
	public static Cube generateRandomCube(){
		Cube generated = new Cube();
		int generatedMoves = 1000;
		Random randomGenerator = new Random();

		//ROTATE THE CUBE WITH RANDOM MOVES
		for(int i =0;i<generatedMoves;i++){
			int number = (randomGenerator.nextInt(100) % 10) +1;

			if(number == 1 ){
				generated.turnLeft(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 2  ){
				generated.turnLeftPrime(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 3  ){
				generated.turnRight(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 4){
				generated.turnRightPrime(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 5 ){
				generated.turnUp(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 6 ){
				generated.turnUpPrime(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 7 ){
				generated.turnDown(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 8 ){
				generated.turnDownPrime(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 9){
				generated.turnBottom(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
			else if(number == 10){
				generated.turnBottomPrime(generated.greenFace);
				theStack.push(number);
				moves.add(number);
			}
		}
		return generated;
	}

	/**
	 * Method to solve a Rubiks cube relying only on Random Moves. (Poor A.I.)
	 * @param generated the cube we want to solve
	 */
	public static void solveCube(Cube generated){
		boolean solved = false;
		Random randomGenerator = new Random();
		while(!solved){
			// MOVE THE COBE RANDOMLY UNTIL WE SOLVE IT (CAN TAKE A LONG TIME)
			int number = (randomGenerator.nextInt(100) % 10) +1;

			if(number == 1 && (generated.greenFace.currentSide.matrix[1][0] != 1)){
				generated.turnLeft(generated.greenFace);
			}
			else if(number == 2  && (generated.greenFace.currentSide.matrix[1][0] != 1)){
				generated.turnLeftPrime(generated.greenFace);
			}
			else if(number == 3  && (generated.greenFace.currentSide.matrix[1][2] != 1)){
				generated.turnRight(generated.greenFace);
			}
			else if(number == 4 && (generated.greenFace.currentSide.matrix[1][2] != 1)){
				generated.turnRightPrime(generated.greenFace);
			}
			else if(number == 5 && (generated.greenFace.currentSide.matrix[0][1] != 1)){
				generated.turnUp(generated.greenFace);
			}
			else if(number == 6 && (generated.greenFace.currentSide.matrix[0][1] != 1)){
				generated.turnUpPrime(generated.greenFace);
			}
			else if(number == 7 && (generated.greenFace.currentSide.matrix[2][1] != 1)){
				generated.turnDown(generated.greenFace);
			}
			else if(number == 8 && (generated.greenFace.currentSide.matrix[2][1] != 1)){
				generated.turnDown(generated.greenFace);
			}
			else if(number == 9){
				generated.turnBottom(generated.greenFace);
			}
			else if(number == 10){
				generated.turnBottomPrime(generated.greenFace);
			}

			if(generated.isBottomGreen() == true){
				break;
			}
		}
	}

	/**
	 * First Method created to solve the green cross of the cube
	 * @param theCube the cube we want to manipulate
	 */
	public static void solveGreenCross(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		Random randomGenerator = new Random();
		while(!solved){
			int number = (randomGenerator.nextInt(100) % 10) +1;

			/*
			if((generated.greenFace.left.matrix[1][2] == 2) && generated.greenFace.currentSide.matrix[1][0] == 1){
				System.err.println("LEFT");
			}
			if(generated.greenFace.right.matrix[1][0] == 4 && generated.greenFace.currentSide.matrix[1][2] == 1){
				System.err.println("RIGHT");
			}
			if((generated.greenFace.up.matrix[2][1] == 5) && generated.greenFace.currentSide.matrix[0][1] == 1){
				System.err.println("UP");
			}
			if((generated.greenFace.down.matrix[0][1] == 3)&& generated.greenFace.currentSide.matrix[2][1] == 1){
				System.err.println("DOWN");
			}


			printCube(generated);
			System.out.println("++++++++");
			System.out.println("++++++++");
			System.out.println("++++++++");
			 */

			int lastMove =0;

			// CHECK IF PARTS OF THE CROSS ARE SOLVED. IF NOT, THEN WE ROTATE THAT CORNER SOMEWHERE ELSE
			if(number == 1 && !(generated.greenFace.left.matrix[1][2] == 2 && generated.greenFace.currentSide.matrix[1][0] == 1 && generated.greenFace.left.matrix[0][1] != 1 && generated.greenFace.left.matrix[2][1] != 1)){
				if(lastMove != 2){
					generated.turnLeft(generated.greenFace);
					lastMove =1;
				}
			}
			else if(number == 2  && !(generated.greenFace.left.matrix[1][2] == 2 && generated.greenFace.currentSide.matrix[1][0] == 1 && generated.greenFace.left.matrix[0][1] != 1 && generated.greenFace.left.matrix[2][1] != 1)){
				if(lastMove != 1){
					lastMove =2;
					generated.turnLeftPrime(generated.greenFace);
				}
			}
			else if(number == 3  && !(generated.greenFace.right.matrix[1][0] == 4 && generated.greenFace.currentSide.matrix[1][2] == 1 && generated.greenFace.right.matrix[0][1] != 1 && generated.greenFace.right.matrix[2][1] != 1)){
				if(lastMove != 4){
					lastMove =3;
					generated.turnRight(generated.greenFace);
				}
			}
			else if(number == 4 && !(generated.greenFace.right.matrix[1][0] == 4 && generated.greenFace.currentSide.matrix[1][2] == 1 && generated.greenFace.right.matrix[0][1] != 1 && generated.greenFace.right.matrix[2][1] != 1)){
				if(lastMove != 3){
					lastMove = 4;
					generated.turnRightPrime(generated.greenFace);
				}
			}
			else if(number == 5 && !(generated.greenFace.up.matrix[2][1] == 5 && generated.greenFace.currentSide.matrix[0][1] == 1 && generated.greenFace.up.matrix[1][0] != 1 && generated.greenFace.up.matrix[1][2] != 1)){
				if(lastMove != 6){
					lastMove = 5;
					generated.turnUp(generated.greenFace);
				}
			}
			else if(number == 6 && !(generated.greenFace.up.matrix[2][1] == 5 && generated.greenFace.currentSide.matrix[0][1] == 1 && generated.greenFace.up.matrix[1][0] != 1 && generated.greenFace.up.matrix[1][2] != 1)){
				if(lastMove != 5){
					lastMove = 6;
					generated.turnUpPrime(generated.greenFace);
				}
			}
			else if(number == 7 && !(generated.greenFace.down.matrix[0][1] == 3 && generated.greenFace.currentSide.matrix[2][1] == 1 && generated.greenFace.down.matrix[1][0] != 1 && generated.greenFace.down.matrix[1][2] != 1)){
				if(lastMove != 8){
					lastMove =7;
					generated.turnDown(generated.greenFace);
				}	
			}
			else if(number == 8 && !(generated.greenFace.down.matrix[0][1] == 3 && generated.greenFace.currentSide.matrix[2][1] == 1)){
				if(lastMove != 7){
					generated.turnDownPrime(generated.greenFace);
				}
			}
			else if(number == 9){
				if(lastMove != 10){
					lastMove =9;
					generated.turnBottom(generated.greenFace);
				}

			}
			else if(number == 10){
				if(lastMove != 9){
					lastMove =10;
					generated.turnBottomPrime(generated.greenFace);
				}
			}


			//HANDLE SPECIAL CASES (CORNER IN CORRECT PLACE, BUT WRONG ORIENTATION)
			if((generated.greenFace.left.matrix[1][2] == 1) && generated.greenFace.currentSide.matrix[1][0] == 2){		
				generated.turnLeftPrime(generated.greenFace);
				generated.turnFront(generated.greenFace);
				generated.turnUpPrime(generated.greenFace);				
				generated.turnFrontPrime(generated.greenFace);				


			}

			else if(generated.greenFace.right.matrix[1][0] == 1 && generated.greenFace.currentSide.matrix[1][2] == 4){
				generated.turnRight(generated.greenFace);		
				generated.turnFrontPrime(generated.greenFace);	
				generated.turnUp(generated.greenFace);	
				generated.turnFront(generated.greenFace);
			}

			else if((generated.greenFace.down.matrix[0][1] == 1)&& generated.greenFace.currentSide.matrix[2][1] == 3){
				generated.turnFrontPrime(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnFront(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);
			}

			else if((generated.greenFace.up.matrix[2][1] == 1) && generated.greenFace.currentSide.matrix[0][1] == 5){
				generated.turnFront(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnFrontPrime(generated.greenFace);
				generated.turnUp(generated.greenFace);
			}

			if(generated.isBottomGreenCross() == true){
				break;
			}
			else{
				//printCube(generated);
			}
		}
	}


	/**
	 * Method to solve a rubiks cube if we have already the turns used to shuffle the cube
	 * @param theCube the shuffled cube
	 */
	public static void solveWithSolution(Cube theCube){
		Cube generated =theCube;

		for(int i=(moves.size()-1);i>=0;i--){
			// GET THE MOVES FROM THE MOVES LIST, and TURN THE OPPOSITE WAY
			int move = moves.get(i);
			if(move ==1){
				generated.turnLeftPrime(generated.greenFace);
			}
			else if(move ==2){
				generated.turnLeft(generated.greenFace);	
			}
			else if(move ==3){
				generated.turnRightPrime(generated.greenFace);
			}
			else if(move ==4){
				generated.turnRight(generated.greenFace);
			}
			else if(move ==5){
				generated.turnUpPrime(generated.greenFace);
			}
			else if(move ==6){
				generated.turnUp(generated.greenFace);
			}
			else if(move ==7){
				generated.turnDownPrime(generated.greenFace);
			}
			else if(move ==8){
				generated.turnDown(generated.greenFace);
			}
			else if(move ==9){
				generated.turnBottomPrime(generated.greenFace);
			}
			else if(move ==10){
				generated.turnBottom(generated.greenFace);
			}
			else{
				System.out.println("NO MOVE");
			}

		}

		if(generated.isSolved()){
			System.out.println("The cube has been solved");

		}
	}


	/**
	 * Method to solve the green side of the Rubiks Cube
	 * @param theCube the cube wa want to solce
	 */
	public static void solveGreenSide(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		Random randomGenerator = new Random();
		//to represent solved sides
		boolean [] solvedSides = {false,false,false,false};
		while(!solved){
			int number = (randomGenerator.nextInt(100) % 4) +1;
			
			// we want to see if we will turn a valid side
			if(solvedSides[number-1] == true){
				boolean numberAssigned = true;

				while(numberAssigned){
					if(solvedSides[number-1] == true){
						if(number+1 > 4){
							number = 1;
						}
						else{
							number++;
						}
					}
					else{
						break;
					}
				}
			}

			if((generated.greenFace.up.matrix[2][2] == 5 && generated.greenFace.currentSide.matrix[0][2] == 1  && generated.greenFace.right.matrix[0][0] == 4)){
				solvedSides[0] = true;
			}
			if((generated.greenFace.down.matrix[0][2] == 3 && generated.greenFace.currentSide.matrix[2][2] == 1  && generated.greenFace.right.matrix[2][0] == 4)){
				solvedSides[1] = true;
			}
			if((generated.greenFace.down.matrix[0][0] == 3 && generated.greenFace.currentSide.matrix[2][0] == 1  && generated.greenFace.left.matrix[2][2] == 2)){
				solvedSides[2] = true;
			}
			if((generated.greenFace.up.matrix[2][0] == 5 && generated.greenFace.left.matrix[0][2] == 2 && generated.greenFace.currentSide.matrix[0][0] == 1)){
				solvedSides[3] = true;
			}

			/*
			 				if(generated.greenFace.up.matrix[2][2] == 5 || generated.greenFace.up.matrix[2][2] == 4 || generated.greenFace.up.matrix[2][2] == 1){
					if(generated.greenFace.currentSide.matrix[0][2] == 5 || generated.greenFace.currentSide.matrix[0][2] == 4 || generated.greenFace.currentSide.matrix[0][2] == 1){
						if(generated.greenFace.right.matrix[0][0] == 5 || generated.greenFace.right.matrix[0][0] == 4 || generated.greenFace.right.matrix[0][0] == 1){
							if(!(generated.greenFace.up.matrix[2][2] == 5 && generated.greenFace.currentSide.matrix[0][2] == 1  && generated.greenFace.right.matrix[0][0] == 4)){

								if(generated.greenFace.currentSide.matrix[0][2] == 4){
									generated.turnFront(generated.greenFace);
									generated.turnRightPrime(generated.greenFace);
									generated.turnBottomPrime(generated.greenFace);
									generated.turnRight(generated.greenFace);
									generated.turnFrontPrime(generated.greenFace);
								}
								else{
									generated.turnFrontPrime(generated.greenFace);
									generated.turnLeftPrime(generated.greenFace);
									generated.turnBottomPrime(generated.greenFace);
									generated.turnLeft(generated.greenFace);
									generated.turnFront(generated.greenFace);
								}

							}
						}
					}
				}
			 */




			if(number ==1 && !(generated.greenFace.up.matrix[2][2] == 5 && generated.greenFace.currentSide.matrix[0][2] == 1  && generated.greenFace.right.matrix[0][0] == 4)){
				if(generated.greenFace.up.matrix[2][2] == 1 || generated.greenFace.right.matrix[0][0] == 1 || generated.greenFace.currentSide.matrix[0][2] == 1){
					generated.turnRight(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);
				}
				//find a corner that has green and put it under the place it belongs
				for(int i=0;i<4;i++){
					if(!(generated.greenFace.back.matrix[0][0] == 1 || generated.greenFace.right.matrix[0][2] == 1 || generated.greenFace.right.matrix[0][2] == 1)){
						if(!(generated.greenFace.up.matrix[0][2] == 4 || generated.greenFace.up.matrix[0][2] == 5)){
							generated.turnBottom(generated.greenFace);	
						}
					}
					else{
						break;
					}
				}


				if(generated.greenFace.back.matrix[0][0] == 1 && (generated.greenFace.up.matrix[0][2] == 4 || generated.greenFace.up.matrix[0][2] == 5)){

					generated.turnUpPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnUp(generated.greenFace);
					/*
					generated.turnRight(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnRight(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);
					 */

				}
				else if(generated.greenFace.right.matrix[0][2] == 1 && (generated.greenFace.up.matrix[0][2] == 4 || generated.greenFace.up.matrix[0][2] == 5)){


					generated.turnRight(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnRightPrime(generated.greenFace); 

				}
				else if(generated.greenFace.up.matrix[0][2] == 1  && (generated.greenFace.right.matrix[0][2] == 4 || generated.greenFace.right.matrix[0][2] == 5)){
					generated.turnUpPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnUp(generated.greenFace);

				}


			}
			else if(number ==2 && !(generated.greenFace.down.matrix[0][2] == 3 && generated.greenFace.currentSide.matrix[2][2] == 1  && generated.greenFace.right.matrix[2][0] == 4)){

				//find corner under right place
				for(int i=0;i<4;i++){
					if(!(generated.greenFace.down.matrix[2][2] == 1 || generated.greenFace.right.matrix[2][2] == 1 || generated.greenFace.back.matrix[2][0] == 1)){
						if(!(generated.greenFace.right.matrix[2][2] == 3 || generated.greenFace.right.matrix[2][2] == 4)){
							generated.turnBottom(generated.greenFace);	
						}
					}
					else{
						break;
					}
				}


				if(generated.greenFace.down.matrix[2][2] == 1 || generated.greenFace.right.matrix[2][0] == 1 || generated.greenFace.currentSide.matrix[2][2] == 1){
					generated.turnRightPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnRight(generated.greenFace);
				}

				if(generated.greenFace.down.matrix[2][2] == 1 && (generated.greenFace.right.matrix[2][2] == 3 || generated.greenFace.right.matrix[2][2] == 4)){
					generated.turnDown(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnDownPrime(generated.greenFace);
				}
				if(generated.greenFace.right.matrix[2][2] == 1 && (generated.greenFace.down.matrix[2][2] == 3 || generated.greenFace.down.matrix[2][2] == 4)){
					generated.turnRightPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRight(generated.greenFace);
				}

			}
			else if(number ==3 && !(generated.greenFace.down.matrix[0][0] == 3 && generated.greenFace.currentSide.matrix[2][0] == 1  && generated.greenFace.left.matrix[2][2] == 2)){

				//find corner under right place
				for(int i=0;i<4;i++){
					if(!(generated.greenFace.down.matrix[2][0] == 1 || generated.greenFace.left.matrix[2][0] == 1 || generated.greenFace.back.matrix[2][2] == 1)){
						if(!(generated.greenFace.down.matrix[2][0] == 3 || generated.greenFace.down.matrix[2][0] == 2)){
							generated.turnBottom(generated.greenFace);	
						}
					}
					else{
						break;
					}
				}

				if(generated.greenFace.down.matrix[2][0] == 1 || generated.greenFace.left.matrix[2][2] == 1 ||  generated.greenFace.currentSide.matrix[2][0] == 1){
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
				}
				if(generated.greenFace.left.matrix[2][0] == 1 && (generated.greenFace.down.matrix[2][0] == 3 || generated.greenFace.down.matrix[2][0] == 2)){
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
				}
				else if(generated.greenFace.down.matrix[2][0] == 1 && (generated.greenFace.left.matrix[2][0] == 3 || generated.greenFace.left.matrix[2][0] == 2)){
					generated.turnDownPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnDown(generated.greenFace);
				}

			}
			else if( number ==4 && !(generated.greenFace.up.matrix[2][0] == 5 && generated.greenFace.left.matrix[0][2] == 2 && generated.greenFace.currentSide.matrix[0][0] == 1)){

				//find corner under right place
				for(int i=0;i<4;i++){
					if(!(generated.greenFace.up.matrix[0][0] == 1 || generated.greenFace.left.matrix[0][0] == 1 || generated.greenFace.back.matrix[0][2] == 1)){
						if(!(generated.greenFace.left.matrix[0][0] == 2 || generated.greenFace.left.matrix[0][0] == 5)){
							generated.turnBottom(generated.greenFace);	
						}
					}
					else{
						break;
					}
				}

				if(generated.greenFace.up.matrix[2][0] == 1 || generated.greenFace.left.matrix[0][2] == 1 || generated.greenFace.currentSide.matrix[0][0] == 1){
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
				}
				if(generated.greenFace.up.matrix[0][0] == 1 && (generated.greenFace.left.matrix[0][0] == 2 || generated.greenFace.left.matrix[0][0] == 5)){
					generated.turnUp(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnUpPrime(generated.greenFace);
				}
				else if(generated.greenFace.left.matrix[0][0] == 1 && (generated.greenFace.up.matrix[0][0] == 2 || generated.greenFace.up.matrix[0][0] == 5)){
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnLeft(generated.greenFace);
				}
			}

			if(generated.isBottomGreenStep()){
				break;
			}
			else{
				generated.turnBottom(generated.greenFace);
				//printCube(generated);
			}
		}
	}

	
	/**
	 * Method to solve the green side (this is the one used)
	 * @param theCube the cube we want to solve
	 */
	public static void solveGreenSideSecond(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		Random randomGenerator = new Random();
		while(!solved){
			int number = (randomGenerator.nextInt(100) % 8) +1;

			// CHECK IF THE CORNER HAS BEEN SOLVED, IF NOT SOLVED THEN PERFORM CORRESPONDING TUEN
			if(number ==1 && !(generated.greenFace.up.matrix[2][2] == 5 && generated.greenFace.currentSide.matrix[0][2] == 1  && generated.greenFace.right.matrix[0][0] == 4)){

				generated.turnRight(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnRightPrime(generated.greenFace); 

			}
			if(number ==2 && !(generated.greenFace.up.matrix[2][2] == 5 && generated.greenFace.currentSide.matrix[0][2] == 1  && generated.greenFace.right.matrix[0][0] == 4)){
				generated.turnUpPrime(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnUp(generated.greenFace);
			}
			if(number ==3 && !(generated.greenFace.down.matrix[0][2] == 3 && generated.greenFace.currentSide.matrix[2][2] == 1  && generated.greenFace.right.matrix[2][0] == 4)){		
				generated.turnDown(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);
			}		
			if(number ==4 && !(generated.greenFace.down.matrix[0][2] == 3 && generated.greenFace.currentSide.matrix[2][2] == 1  && generated.greenFace.right.matrix[2][0] == 4)){
				generated.turnRightPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
			}
			if(number ==5 && !(generated.greenFace.down.matrix[0][0] == 3 && generated.greenFace.currentSide.matrix[2][0] == 1  && generated.greenFace.left.matrix[2][2] == 2)){

				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);


			}
			if(number ==6 && !(generated.greenFace.down.matrix[0][0] == 3 && generated.greenFace.currentSide.matrix[2][0] == 1  && generated.greenFace.left.matrix[2][2] == 2)){
				generated.turnDownPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
			}
			if( number ==7 && !(generated.greenFace.up.matrix[2][0] == 5 && generated.greenFace.left.matrix[0][2] == 2 && generated.greenFace.currentSide.matrix[0][0] == 1)){
				generated.turnUp(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnUpPrime(generated.greenFace);

			}
			if( number ==8 && !(generated.greenFace.up.matrix[2][0] == 5 && generated.greenFace.left.matrix[0][2] == 2 && generated.greenFace.currentSide.matrix[0][0] == 1)){
				generated.turnLeftPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnLeft(generated.greenFace);
			}

			//BREAK IF SOLVED
			if(generated.isBottomGreenStep()){
				break;
			}
			else{
				generated.turnBottom(generated.greenFace);
			}
		}
	}

	
	/**
	 * Method used to solve the second layer of the cube (after solving the cross)
	 * @param theCube cube we want to solve
	 */
	public static void solveSecondLayer(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		int invalidSides = 0;
		while(!solved){
			if(generated.greenFace.back.matrix[2][1] ==6 || generated.greenFace.down.matrix[2][1] ==6){
				invalidSides++;
			}
			if(generated.greenFace.back.matrix[1][2] ==6 || generated.greenFace.left.matrix[1][0] == 6){
				invalidSides++;
			}
			if(generated.greenFace.back.matrix[0][1] ==6 || generated.greenFace.up.matrix[0][1] == 6){
				invalidSides++;
			}
			if(generated.greenFace.back.matrix[1][0] ==6 || generated.greenFace.right.matrix[1][2] == 6){
				invalidSides++;
			}
			// move bottom to match 
			if(generated.greenFace.down.matrix[2][1] == 3){
				if(generated.greenFace.back.matrix[2][1] == 4){
					//left
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnRight(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnDown(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnDownPrime(generated.greenFace);
					continue;
				}
				if(generated.greenFace.back.matrix[2][1] == 2){
					//right
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnDownPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnDown(generated.greenFace);
					continue;
				}	
				else{
					if(((generated.greenFace.down.matrix[1][0] != 3 || generated.greenFace.left.matrix[2][1] != 2) && invalidSides >= 3) || (generated.greenFace.down.matrix[1][0] == 2 || generated.greenFace.left.matrix[2][1] == 3)){
						generated.turnBottom(generated.greenFace);
						generated.turnLeft(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnLeftPrime(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnDownPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnDown(generated.greenFace);
						
						System.err.println("Random Move 1");
						continue;
					}
					else if(((generated.greenFace.down.matrix[1][2] != 3 || generated.greenFace.right.matrix[2][1] !=4) && invalidSides >= 3) || (generated.greenFace.down.matrix[1][0] == 2 || generated.greenFace.left.matrix[2][1] == 3)){
						generated.turnBottomPrime(generated.greenFace);
						generated.turnRightPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnRight(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnDown(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnDownPrime(generated.greenFace);
						
						System.err.println("Random Move 2");
						continue;
					}
				}
			}
			// check where the corner should go in the cube
			if(generated.greenFace.left.matrix[1][0] == 2){
				if(generated.greenFace.back.matrix[1][2] == 5){
					//right
					generated.turnBottom(generated.greenFace);
					generated.turnUp(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnUpPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					continue;
				}
				if(generated.greenFace.back.matrix[1][2] == 3){
					//left
					generated.turnBottomPrime(generated.greenFace);
					generated.turnDownPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnDown(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					continue;
				}			

				else{
					if(((generated.greenFace.left.matrix[2][1] != 2 || generated.greenFace.down.matrix[1][0] != 3) && invalidSides >= 3) || (generated.greenFace.left.matrix[0][1] == 5 && generated.greenFace.up.matrix[1][0] == 2)){
						generated.turnBottomPrime(generated.greenFace);
						generated.turnDownPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnDown(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnLeft(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnLeftPrime(generated.greenFace);
						
						System.err.println("Random Move 3");
						continue;
					}
					// example it should be left white and up red. and we get left red and up white.
					else if(((generated.greenFace.left.matrix[0][1] != 2 || generated.greenFace.up.matrix[1][0] != 5) && invalidSides >= 3) || (generated.greenFace.left.matrix[0][1] == 5 && generated.greenFace.up.matrix[1][0] == 2)){
						generated.turnBottom(generated.greenFace);
						generated.turnUp(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnUpPrime(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnLeftPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnLeft(generated.greenFace);
						
						System.err.println("Random Move 4");
						continue;
					}
				}
			}
			// check where the corner should go in the cube
			if(generated.greenFace.right.matrix[1][2] == 4){
				if(generated.greenFace.back.matrix[1][0] == 5){
					//left
					generated.turnBottomPrime(generated.greenFace);
					generated.turnUpPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnUp(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnRight(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);	
					continue;
				}
				if(generated.greenFace.back.matrix[1][0] == 3){
					//right
					//r= down
					//r' = downPrime
					generated.turnBottom(generated.greenFace);
					generated.turnDown(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnDownPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);	
					generated.turnBottom(generated.greenFace);
					generated.turnRight(generated.greenFace);
					continue;

				}			

				else{
					if(((generated.greenFace.right.matrix[2][1] != 4 || generated.greenFace.down.matrix[1][2] != 3) && invalidSides >= 3) || (generated.greenFace.right.matrix[2][1] == 3 || generated.greenFace.down.matrix[1][2] == 4)){
						generated.turnBottom(generated.greenFace);
						generated.turnDown(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnDownPrime(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnRightPrime(generated.greenFace);	
						generated.turnBottom(generated.greenFace);
						generated.turnRight(generated.greenFace);
						System.err.println("Random Move 5");
						
						continue;
					}
					else if(((generated.greenFace.right.matrix[0][1] != 4 || generated.greenFace.up.matrix[1][2] != 5) && invalidSides >= 3) || (generated.greenFace.right.matrix[2][1] == 3 || generated.greenFace.down.matrix[1][2] == 4)){
						generated.turnBottomPrime(generated.greenFace);
						generated.turnUpPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnUp(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnRight(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnRightPrime(generated.greenFace);
						System.err.println("Random Move 6");
						
						continue;
					}
				}

			}
			// check where the corner should go in the cube
			if(generated.greenFace.up.matrix[0][1] == 5){
				if(generated.greenFace.back.matrix[0][1] == 2){
					//left
					generated.turnBottomPrime(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnUp(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnUpPrime(generated.greenFace);
					continue;
				}
				if(generated.greenFace.back.matrix[0][1] == 4){
					//right
					generated.turnBottom(generated.greenFace);
					generated.turnRight(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnRightPrime(generated.greenFace);
					generated.turnBottomPrime(generated.greenFace);
					generated.turnUpPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnUp(generated.greenFace);
					continue;
				}			

				// Make random turn in case no corners were correctly placed and if we are not done
				else{
					if(((generated.greenFace.up.matrix[1][2] != 5 || generated.greenFace.right.matrix[0][1] != 4) && invalidSides >= 3) || (generated.greenFace.up.matrix[1][2] == 4 || generated.greenFace.right.matrix[0][1] == 5)){
						generated.turnBottom(generated.greenFace);
						generated.turnRight(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnRightPrime(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnUpPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnUp(generated.greenFace);
						System.err.println("Random Move 7");
						
						continue;
					}
					else if(((generated.greenFace.up.matrix[1][0] != 5 || generated.greenFace.left.matrix[0][1] != 2) && invalidSides >= 3) || (generated.greenFace.up.matrix[1][2] == 4 || generated.greenFace.right.matrix[0][1] == 5)){
						generated.turnBottomPrime(generated.greenFace);
						generated.turnLeftPrime(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnLeft(generated.greenFace);
						generated.turnBottom(generated.greenFace);
						generated.turnUp(generated.greenFace);
						generated.turnBottomPrime(generated.greenFace);
						generated.turnUpPrime(generated.greenFace);
						System.err.println("Random Move 8");
						
						continue;
					}
				}

			}
			
			// BREAK IF THE SECOND LAYER IS DONE. OTHERWISE WE ROTATE THE BOTTOM AND KEEP LOOPING
			if(generated.isSecondLayerDone()){
				break;
			}
			else{
				invalidSides = 0;
				//printCube(generated);
				generated.turnBottom(generated.greenFace);
			}
		}

	}


	
	/**
	 * Method to solve the cross on the side above the green cross (blue side)
	 * @param theCube cube we want to solve
	 */
	private static void solveTopCross(Cube theCube) {
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		int blueCorners = 0;
		while(!solved){
			// CHECK NUMBER OF CORNERS SOLVED 
			if(generated.greenFace.back.matrix[0][1] == 6){
				blueCorners++;
			}
			if(generated.greenFace.back.matrix[1][0] == 6){
				blueCorners++;
			}
			if(generated.greenFace.back.matrix[1][2] == 6){
				blueCorners++;
			}
			if(generated.greenFace.back.matrix[2][1] == 6){
				blueCorners++;
			}

			// PERFORM AN ALGORITHM DEPENDING ON THE NUMBER OF SOLVED SIDES
			if(generated.greenFace.back.matrix[1][0] == 6 && generated.greenFace.back.matrix[1][1] == 6 && generated.greenFace.back.matrix[1][2] == 6){
				//for a line
				generated.turnDown(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);
			}
			else if(generated.greenFace.back.matrix[1][2] == 6 && generated.greenFace.back.matrix[1][1] == 6 && generated.greenFace.back.matrix[2][1] == 6){
				//for an 'L' shape
				generated.turnDownDouble(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnDownDoublePrime(generated.greenFace);
			}
			else if(blueCorners == 0){
				//for a line
				generated.turnDown(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);

				//for an 'L' shape
				generated.turnDownDouble(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnDownDoublePrime(generated.greenFace);

			}

			//KEEP LOOPING IF WE ARE NOT DONE
			if(generated.isBlueCross()){
				break;
			}
			else{
				//printCube(generated);
				generated.turnBottom(generated.greenFace);
				blueCorners = 0;
			}
		}

	}

	/**
	 * Method to solve the blue side
	 * @param theCube cube we want to solve
	 */
	public static void solveTop(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		int solvedCorners =0;
		while(!solved){
			// check number of solved corners
			if(generated.greenFace.back.matrix[0][0]==6){
				solvedCorners++;
			}
			if(generated.greenFace.back.matrix[0][2]==6){
				solvedCorners++;
			}
			if(generated.greenFace.back.matrix[2][0]==6){
				solvedCorners++;
			}
			if(generated.greenFace.back.matrix[2][2]==6){
				solvedCorners++;
			}

			// depending on the number of solved corners, we will perform an algorithm
			if(solvedCorners ==0){
				if(generated.greenFace.right.matrix[2][2] == 6){
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
				}
			}
			else if(solvedCorners == 1){
				if(generated.greenFace.back.matrix[2][0]==6){
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
				}
			}
			else if(solvedCorners ==2){
				if(generated.greenFace.down.matrix[2][2]==6){
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeft(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnBottom(generated.greenFace);
					generated.turnLeftPrime(generated.greenFace);
				}
			}

			//Keep looping if we are not done, and reset the number of solved sides to 0
			if(generated.isBlueBottom()){
				break;
			}
			else{
				//printCube(generated);
				solvedCorners =0;
				generated.turnBottom(generated.greenFace);
			}
		}
	}

	/**
	 * Method to solve the headlights on the third layer of the cube
	 * @param theCube cube we want to solve
	 */
	public static void solveHeadlights(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		while(!solved){
			int solvedHeadlights =0;
			//Loops to check if we already have all the headlights
			if(generated.greenFace.up.matrix[0][0] == generated.greenFace.up.matrix[0][2]){
				solvedHeadlights++;
				if(generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[2][0]){
					solvedHeadlights++;
					if(generated.greenFace.right.matrix[0][2] == generated.greenFace.right.matrix[2][2]){
						solvedHeadlights++;
						if(generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[2][2]){
							boolean resolved = true;

							if(generated.greenFace.up.matrix[0][0] != generated.greenFace.up.matrix[1][0]){
								resolved = false;
								generated.turnBottom(generated.greenFace);
							}
							else if(generated.greenFace.left.matrix[0][0] != generated.greenFace.left.matrix[0][1]){
								resolved = false;
								generated.turnBottom(generated.greenFace);
							}
							else if(generated.greenFace.right.matrix[0][2] !=generated.greenFace.right.matrix[0][1]){
								resolved = false;
								generated.turnBottom(generated.greenFace);
							}
							else if(generated.greenFace.down.matrix[2][0] != generated.greenFace.down.matrix[1][0]){
								resolved = false;
								generated.turnBottom(generated.greenFace);
							}

							if(resolved){
								break;
							}
							else{
								continue;
							}
						}	
					}	
				}
			}
			//not all headlights are matching
			if(solvedHeadlights == 0){
				generated.turnRightPrime(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnUpPrime(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnRight(generated.greenFace);
				
				continue;
			}

			if((generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[2][2]) && (generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[1][0])){
				//ORANGE HEADLIGHTS
				generated.turnRightPrime(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnUpPrime(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnRight(generated.greenFace);
			}
			else if((generated.greenFace.right.matrix[0][2] == generated.greenFace.right.matrix[2][2]) && (generated.greenFace.right.matrix[0][2] ==generated.greenFace.right.matrix[0][1])){
				generated.turnUpPrime(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnUpPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnUpPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnUp(generated.greenFace);
			}
			else if((generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[2][0]) && (generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[0][1])){
				generated.turnDownPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnDown(generated.greenFace);
			}
			else if((generated.greenFace.up.matrix[0][0] == generated.greenFace.up.matrix[0][2]) && (generated.greenFace.up.matrix[0][0] == generated.greenFace.up.matrix[1][0])){
				generated.turnLeftPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnDownPrime(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnLeft(generated.greenFace);
			}
			else{
				generated.turnBottom(generated.greenFace);
			}
		}
	}

	/**
	 * method to finish all the sides of the cube (Must be almost solved).
	 * @param theCube The cube that we want to solve, and has gone through all the other algorithms
	 */
	public static void solveFinal(Cube theCube){
		Cube generated = new Cube();
		generated = theCube; 
		boolean solved = false;
		while(!solved){
			
			/*
			int topSolved = 0;
			if(generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[1][0]  && generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[2][0]){
				topSolved++;
				if(generated.greenFace.left.matrix[0][0] != generated.greenFace.left.matrix[0][0]){
					generated.turnBottom(generated.greenFace);
				}
			}
			if(generated.greenFace.right.matrix[0][2] == generated.greenFace.right.matrix[1][2]  && generated.greenFace.right.matrix[0][2] == generated.greenFace.right.matrix[2][2]){
				topSolved++;
				if(generated.greenFace.right.matrix[0][2] != generated.greenFace.right.matrix[1][1]){
					generated.turnBottom(generated.greenFace);
				}
			}
			if(generated.greenFace.up.matrix[0][0] == generated.greenFace.up.matrix[0][2]  && generated.greenFace.up.matrix[0][1] == generated.greenFace.up.matrix[0][2]){
				topSolved++;
				if(generated.greenFace.up.matrix[0][0] != generated.greenFace.up.matrix[1][1]){
					generated.turnBottom(generated.greenFace);
				}
			}
			if(generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[2][2]  && generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[2][1]){
				topSolved++;
				if(generated.greenFace.down.matrix[2][0] != generated.greenFace.down.matrix[1][1]){
					generated.turnBottom(generated.greenFace);
				}
			}
			 */
			
			boolean resolved = true;
			while(true){
				resolved = true;
				//check headlights
				if(generated.greenFace.up.matrix[0][0] != generated.greenFace.up.matrix[1][0]){
					resolved = false;
					generated.turnBottom(generated.greenFace);
				}
				else if(generated.greenFace.left.matrix[0][0] != generated.greenFace.left.matrix[0][1]){
					resolved = false;
					generated.turnBottom(generated.greenFace);
				}
				else if(generated.greenFace.right.matrix[0][2] !=generated.greenFace.right.matrix[0][1]){
					resolved = false;
					generated.turnBottom(generated.greenFace);
				}
				else if(generated.greenFace.down.matrix[2][0] != generated.greenFace.down.matrix[1][0]){
					resolved = false;
					generated.turnBottom(generated.greenFace);
				}

				if(resolved){
					break;
				}
				continue;
			}
			
			// check if we have solved sides. If we have one, then we must place if on the back first and perform an algorithm
			if(generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[2][2]  && generated.greenFace.down.matrix[2][0] == generated.greenFace.down.matrix[2][1]){
				// red facing me
				generated.turnRight(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnRight(generated.greenFace);
			}
			else if(generated.greenFace.up.matrix[0][0] == generated.greenFace.up.matrix[0][2]  && generated.greenFace.up.matrix[0][1] == generated.greenFace.up.matrix[0][2]){
				generated.turnLeft(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnLeftPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnLeft(generated.greenFace);
				generated.turnLeft(generated.greenFace);
			}
			else if(generated.greenFace.right.matrix[0][2] == generated.greenFace.right.matrix[1][2]  && generated.greenFace.right.matrix[0][2] == generated.greenFace.right.matrix[2][2]){
				generated.turnUp(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);				
				generated.turnUp(generated.greenFace);
				generated.turnBottom(generated.greenFace);			
				generated.turnUp(generated.greenFace);
				generated.turnBottom(generated.greenFace);				
				generated.turnUp(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);				
				generated.turnUpPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnUp(generated.greenFace);
				generated.turnUp(generated.greenFace);
			}
			else if(generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[1][0]  && generated.greenFace.left.matrix[0][0] == generated.greenFace.left.matrix[2][0]){
				generated.turnDown(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);	
				generated.turnDown(generated.greenFace);
				generated.turnBottom(generated.greenFace);	
				generated.turnDown(generated.greenFace);
				generated.turnBottom(generated.greenFace);	
				generated.turnDown(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);	
				generated.turnDownPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnDown(generated.greenFace);
				generated.turnDown(generated.greenFace);
			}
			// IF WE HAVE NO SOLVED SIDES, THEN WE PERFORM ANY ALGORITHM 
			else{
				// red facing me
				generated.turnRight(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnBottom(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRightPrime(generated.greenFace);
				generated.turnBottomPrime(generated.greenFace);
				generated.turnRight(generated.greenFace);
				generated.turnRight(generated.greenFace);
			}
			

			if(generated.isSolved()){
				break;
			}
		}
	}

}

